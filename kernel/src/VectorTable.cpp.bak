#include <VectorTable.h>
#include <string>
#include <vector>
#include <filesystem>
#include <iostream>
#include <stdexcept>
#include <memory>
#include <unordered_map>

#include <sqlite3.h>
#include <faiss/Index.h>
#include <faiss/index_io.h>
#include <faiss/index_factory.h>

void VectorTable::createTable(const std::string &dbPath_, const std::string &tableName_, int dimension_)
{
    if(sqliteDB != nullptr)
        throw std::runtime_error("SQLite database is already opened, cannot create before close it.");
    if(faissIndex != nullptr)
        throw std::runtime_error("Faiss index is already openedm, cannot create before close it.");
    if(std::filesystem::exists(dbPath_ + "/" + tableName_ + ".db")
        || std::filesystem::exists(dbPath_ + "/" + tableName_ + ".faiss"))
        throw std::runtime_error("Database already exists: " + dbPath_ + "/" + tableName_ + ".db");

    dbPath = dbPath_;
    tableName = tableName_;
    dimension = dimension_;

    // check if the directory exists, if not, create it
    if (!std::filesystem::exists(dbPath))
        std::filesystem::create_directories(dbPath);
    
    // try to create SQLite database
    std::string dbFullPath = dbPath + "/" + tableName;
    sqlite3 *dbHandle = nullptr;
    auto returnCode = sqlite3_open_v2((dbFullPath + ".db").c_str(), &dbHandle, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | SQLITE_OPEN_URI, nullptr);
    if (returnCode != SQLITE_OK)
        throw std::runtime_error("Failed to create SQLite database: " + dbFullPath + ".db" + "\n    sqlite error " + sqlite3_errmsg(sqliteDB.get()));
    sqliteDB.reset(dbHandle);

    // initialize SQLite table
    initializeSQLiteTable();

    // create Faiss index in memory
    faissIndex.reset((faiss::index_factory(dimension, faissIndexType.c_str(), metricType)));
    if(faissIndex == nullptr) 
        throw std::runtime_error("Failed to create Faiss index in memory.");

    // write Faiss index to disk
    faiss::write_index(faissIndex.get(), (dbFullPath + ".faiss").c_str());
}

void VectorTable::initializeSQLiteTable()
{
    if (sqliteDB == nullptr)
        throw std::runtime_error("SQLite database is not created.");

    const char *createTableSQL = R"(
        CREATE TABLE 
        Vector(
            id INTEGER PRIMARY KEY AUTOINCREMENT, --主键，自动递增 
            valid BOOLEAN NOT NULL DEFAULT 0, --布尔值，默认值为 false(0), 说明向量是否已写入内存中的Faiss数据库 
            writeback BOOLEAN NOT NULL DEFAULT 0, --布尔值，默认值为 false(0), 说明向量是否已写入磁盘中的Faiss数据库
            deleted BOOLEAN NOT NULL DEFAULT 0 --布尔值，默认值为 false(0), 说明向量是否已删除
        );
    )";

    auto returnCode = sqlite3_exec(sqliteDB.get(), createTableSQL, nullptr, nullptr, nullptr);
    if (returnCode != SQLITE_OK)
        throw std::runtime_error("Failed to create SQLite table: " + std::string(sqlite3_errmsg(sqliteDB.get())));
}

void VectorTable::open(const std::string &dbPath_, const std::string &tableName_)
{
    if (sqliteDB != nullptr)
        throw std::runtime_error("SQLite database is already opened, cannot create before close it.");
    if (faissIndex != nullptr)
        throw std::runtime_error("Faiss index is already openedm, cannot create before close it.");

    dbPath = dbPath_;
    tableName = tableName_;

    // check if the directory exists, if not, create it
    if (!std::filesystem::exists(dbPath))
        throw std::runtime_error("Database path does not exist: " + dbPath);

    // try open SQLite database
    std::string dbFullPath = dbPath + "/" + tableName;
    sqlite3 *dbHandle = nullptr;
    auto returnCode = sqlite3_open_v2((dbFullPath + ".db").c_str(), &dbHandle, SQLITE_OPEN_READWRITE | SQLITE_OPEN_URI, nullptr);
    if (returnCode != SQLITE_OK)
        throw std::runtime_error("Failed to open SQLite database: " + dbFullPath + ".db" + "\n    sqlite error " + sqlite3_errmsg(sqliteDB.get()));
    sqliteDB.reset(dbHandle);
    
    // try open Faiss index
    faissIndex.reset(faiss::read_index((dbFullPath + ".faiss").c_str()));
    if (faissIndex == nullptr)
        throw std::runtime_error("Failed to open Faiss index: " + dbFullPath + ".faiss");
    dimension = faissIndex->d;
}

void VectorTable::close()
{
    if(sqliteDB == nullptr)
        throw std::runtime_error("SQLite database is not opened.");
    if(faissIndex == nullptr)
        throw std::runtime_error("Faiss index is not opened.");
    
    reconstructFaissIndex();
    writeToDisk(); // write Faiss index to disk

    sqliteDB.reset(); // close SQLite database
    faissIndex.reset(); // close Faiss index
}

VectorTable::~VectorTable()
{
    if (faissIndex != nullptr)
    {
        reconstructFaissIndex();
        writeToDisk();
    }
}

// a slowly version
std::pair<std::vector<faiss::idx_t>, std::vector<float>> VectorTable::querySimlar(const std::vector<float> &queryVector, int maxResultCount) const
{
    if(faissIndex == nullptr)
        throw std::runtime_error("VectorTable is not initialized.");
    if(queryVector.size() != dimension)
        throw std::runtime_error("Query vector dimension does not match the VectorTable dimension.");
    if(!faissIndex->is_trained)
        throw std::runtime_error("Faiss index is not trained.");
    if(maxResultCount <= 0)
        throw std::runtime_error("Result count must be greater than 0.");
    
    //search from index
    auto resultIndex = std::vector<faiss::idx_t>(maxResultCount);
    auto resultDistance = std::vector<float>(maxResultCount);
    faissIndex->search(1, queryVector.data(), maxResultCount, resultDistance.data(), resultIndex.data());

    // check if the result's valid flag and deleted flag in SQLite table
    // prepare vectors to store valid results
    std::vector<faiss::idx_t> validResultIndex;
    std::vector<float> validResultDistance;
    validResultIndex.reserve(maxResultCount);
    validResultDistance.reserve(maxResultCount);

    // query ids in resultIndex
    std::string idList;
    for (auto& i : resultIndex)
    {
        if (i > 0)
            idList += ",";
        idList += std::to_string(i);
    }
    const std::string querySQL = "SELECT id, valid, deleted FROM Vector WHERE id IN (" + idList + ");";
    sqlite3_stmt *stmt = nullptr;
    auto returnCode = sqlite3_prepare_v2(sqliteDB.get(), querySQL.c_str(), -1, &stmt, nullptr);
    if (returnCode != SQLITE_OK)
        throw std::runtime_error("Failed to prepare SQLite statement: " + std::string(sqlite3_errmsg(sqliteDB.get())));
    std::unordered_map<faiss::idx_t, std::pair<bool, bool>> idToFlagMap; //pair.first is valid, pair.second is deleted
    try{
        while (sqlite3_step(stmt) == SQLITE_ROW)  // store flag in idtToFlagMap
        {
            auto id = sqlite3_column_int64(stmt, 0);
            auto valid = sqlite3_column_int(stmt, 1);
            auto deleted = sqlite3_column_int(stmt, 2);
            idToFlagMap[id] = {valid != 0, deleted != 0};
        }
        for(auto& id : resultIndex) // filter unexpected results
        {
            auto flagPair = idToFlagMap[id];
            if(flagPair.first && !flagPair.second) // only keep ids with valid = true and deleted = false 
            {
                validResultIndex.push_back(id);
                validResultDistance.push_back(resultDistance[id]);
            }
        }
    } catch (...) {
        if(stmt) sqlite3_finalize(stmt);
        throw;
    }
    return {resultIndex, resultDistance};
}

std::vector<float> VectorTable::getVectorFromId(faiss::idx_t id) const
{
    if(faissIndex == nullptr)
        throw std::runtime_error("VectorTable is not initialized.");
    if(id < 0 || id >= faissIndex->ntotal)
        throw std::runtime_error("Id is out of range.");

    // get vector from index
    auto vector = std::vector<float>(dimension);
    faissIndex->reconstruct(id, vector.data());

    return vector;
}

int VectorTable::writeToDisk()
{
    if(faissIndex == nullptr)
        throw std::runtime_error("FaissIndex is not initialized.");
    if(addCount == 0)
        return 0; // no need to write to disk

    // avoid overwriting the old index file while writing the new one
    std::string backupFile = dbPath + "/" + tableName + ".faiss.new";
    faiss::write_index(faissIndex.get(), backupFile.c_str());
    // remove old index file and rename the new one
    std::filesystem::remove(dbPath + "/" + tableName + ".faiss");
    std::filesystem::rename(backupFile, dbPath + "/" + tableName + ".faiss");

    // change falg in SQLite table
    const char *updateSQL = R"(
        UPDATE Vector
        SET writeback = 1
        WHERE valid = 1 AND writeback = 0;
    )";
    auto returnCode = sqlite3_exec(sqliteDB.get(), updateSQL, nullptr, nullptr, nullptr);
    if (returnCode != SQLITE_OK)
        throw std::runtime_error("Failed to update SQLite table: " + std::string(sqlite3_errmsg(sqliteDB.get())));
    int changedCount = sqlite3_changes(sqliteDB.get());

    addCount = 0; // reset add count
    return changedCount;
}

VectorTable::idx_t VectorTable::addVector(const std::vector<float> &vector)
{
    if(faissIndex == nullptr)
        throw std::runtime_error("FaissIndex is not initialized.");
    if(sqliteDB == nullptr)
        throw std::runtime_error("SQLite database is not initialized.");
    if(vector.size() != dimension)
        throw std::runtime_error("Vector dimension does not match the VectorTable dimension.");

    // add vector to SQLite table, but set flag invalid
    const char *insertSQL = "INSERT INTO Vector (valid) VALUES (0);";
    auto returnCode = sqlite3_exec(sqliteDB.get(), insertSQL, nullptr, nullptr, nullptr);
    if (returnCode != SQLITE_OK)
        throw std::runtime_error("Failed to insert into SQLite table: " + std::string(sqlite3_errmsg(sqliteDB.get())));
    auto id = static_cast<idx_t>(sqlite3_last_insert_rowid(sqliteDB.get()));

    // add vector to Faiss index
    faissIndex->add_with_ids(1, vector.data(), &id);

    // add successfully, change flag in SQLite table
    const char *updateSQL = "UPDATE Vector SET valid = 1 WHERE id = ?;";
    sqlite3_stmt *stmt = nullptr;
    returnCode = sqlite3_prepare_v2(sqliteDB.get(), updateSQL, -1, &stmt, nullptr);
    if (returnCode != SQLITE_OK)
        throw std::runtime_error("Failed to prepare SQLite statement: " + std::string(sqlite3_errmsg(sqliteDB.get())));
    try{ // prevent stmt leaked
        sqlite3_bind_int64(stmt, 1, id);
        returnCode = sqlite3_step(stmt);
        if (returnCode != SQLITE_DONE)
            throw std::runtime_error("Failed to update SQLite table: " + std::string(sqlite3_errmsg(sqliteDB.get())));
    } catch (...) {
        if(stmt) sqlite3_finalize(stmt);
        throw;
    }
    if(stmt) sqlite3_finalize(stmt);

    // check if need to write to disk
    addCount++;
    if (addCount >= maxAddCoune) 
        writeToDisk();

    return id;
}

// this function will only mark the vector as invalid in SQLite table, cannot remove it from Faiss index
VectorTable::idx_t VectorTable::removeVector(idx_t id)
{
    if (faissIndex == nullptr)
        throw std::runtime_error("FaissIndex is not initialized.");
    if (sqliteDB == nullptr)
        throw std::runtime_error("SQLite database is not initialized.");
    if (id < 0 || id >= faissIndex->ntotal)
        throw std::runtime_error("Id is out of range.");
    
    // sign the vector by valid = false in SQLite table
    const char *updateSQL = "UPDATE Vector SET deleted = 1 WHERE id = ?;";
    sqlite3_stmt *stmt = nullptr;
    auto returnCode = sqlite3_prepare_v2(sqliteDB.get(), updateSQL, -1, &stmt, nullptr);
    if (returnCode != SQLITE_OK)
        throw std::runtime_error("Failed to prepare SQLite statement: " + std::string(sqlite3_errmsg(sqliteDB.get())));
    try{ // prevent stmt leaked
        sqlite3_bind_int64(stmt, 1, id);
        returnCode = sqlite3_step(stmt);
        if (returnCode != SQLITE_DONE)
            throw std::runtime_error("Failed to update SQLite table: " + std::string(sqlite3_errmsg(sqliteDB.get())));
    } catch (...) {
        if(stmt) sqlite3_finalize(stmt);
        throw;
    }
    
    // check if need to reconstruct Faiss index
    deleteCount++;
    if (deleteCount >= maxDeleteCount)
        reconstructFaissIndex();

    return id;
}

// all valid = false or delete = true vectors will be removed from Faiss index, but only delete = true vectors will be removed from SQLite table 
int VectorTable::reconstructFaissIndex()
{
    if(faissIndex == nullptr)
        throw std::runtime_error("FaissIndex is not initialized.");
    if(sqliteDB == nullptr)
        throw std::runtime_error("SQLite database is not initialized.");
    if(deleteCount == 0)
        return 0; // no need to reconstruct Faiss index
    
    // get all valid idx from SQL table
    const char *querySQL = "SELECT id FROM Vector WHERE valid = 1 AND deleted = 0;";
    sqlite3_stmt *stmt = nullptr;
    auto returnCode = sqlite3_prepare_v2(sqliteDB.get(), querySQL, -1, &stmt, nullptr);
    if (returnCode != SQLITE_OK)
        throw std::runtime_error("Failed to prepare SQLite statement: " + std::string(sqlite3_errmsg(sqliteDB.get())));
    std::vector<faiss::idx_t> validIdList;
    try{
        while (sqlite3_step(stmt) == SQLITE_ROW)  // store valid ids in validIdList
        {
            auto id = sqlite3_column_int64(stmt, 0);
            validIdList.push_back(id);
        }
    } catch (...) {
        if(stmt) sqlite3_finalize(stmt);
        throw;
    }

    // get valid vectors by valid ids from faiss index
    auto validVectors = std::vector<float>(validIdList.size() * dimension);
    faissIndex->reconstruct_batch(validIdList.size(), validIdList.data(), validVectors.data());

    // create new Faiss index in memory
    faiss::Index *newFaissIndex = faiss::index_factory(dimension, faissIndexType.c_str(), metricType);
    if (newFaissIndex == nullptr)
        throw std::runtime_error("Failed to create new Faiss index in memory.");
    newFaissIndex->add(validIdList.size(), validVectors.data()); // add all valid vectors to new Faiss index

    // update SQL table, remove the droped vectors
    const char *deleteSQL = R"(
        DELETE FROM Vector
        WHERE deleted = 1;
    )";
    returnCode = sqlite3_exec(sqliteDB.get(), deleteSQL, nullptr, nullptr, nullptr);
    if (returnCode != SQLITE_OK)
        throw std::runtime_error("Failed to delete from SQLite table: " + std::string(sqlite3_errmsg(sqliteDB.get())));
    int deletedCount = sqlite3_changes(sqliteDB.get());

    // save new Faiss index
    faissIndex.reset(newFaissIndex);
    writeToDisk();

    deleteCount = 0; // reset delete count

    return deletedCount;
}

std::vector<VectorTable::idx_t> VectorTable::getInvalidIds() const
{
    if (sqliteDB == nullptr)
        throw std::runtime_error("SQLite database is not initialized.");

    // get all invalid ids from SQL table
    const char *querySQL = "SELECT id FROM Vector WHERE valid = 0 AND deleted = 0;";
    sqlite3_stmt *stmt = nullptr;
    auto returnCode = sqlite3_prepare_v2(sqliteDB.get(), querySQL, -1, &stmt, nullptr);
    if (returnCode != SQLITE_OK)
        throw std::runtime_error("Failed to prepare SQLite statement: " + std::string(sqlite3_errmsg(sqliteDB.get())));
    
    std::vector<idx_t> invalidIdList;
    try{
        while (sqlite3_step(stmt) == SQLITE_ROW)  // store invalid ids in invalidIdList
        {
            auto id = sqlite3_column_int64(stmt, 0);
            invalidIdList.push_back(id);
        }
    } catch (...) {
        if(stmt) sqlite3_finalize(stmt);
        throw;
    }
    
    return invalidIdList;
}